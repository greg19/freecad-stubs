import logging
import re
from collections.abc import Iterable
from inspect import Parameter

from freecad_stub_gen.cpp_code.converters import validatePythonValue
from freecad_stub_gen.generators.common.annotation_parameter import RawRepr
from freecad_stub_gen.generators.common.cpp_function import (
    findFunctionCall,
    generateExpressionUntilChar,
    genFuncArgs,
)
from freecad_stub_gen.generators.common.return_type_converter.arg_types import (
    InvalidReturnType,
    RetType,
    UnionArgument,
)
from freecad_stub_gen.generators.common.return_type_converter.base import (
    ReturnTypeConverterBase,
)
from freecad_stub_gen.generators.common.return_type_converter.inner_type_dict import (
    ReturnTypeInnerDict,
)
from freecad_stub_gen.generators.common.return_type_converter.inner_type_list import (
    ReturnTypeInnerList,
)
from freecad_stub_gen.generators.common.return_type_converter.inner_type_tuple import (
    ReturnTypeInnerTuple,
)
from freecad_stub_gen.generators.exceptions.container import exceptionContainer
from freecad_stub_gen.ordered_set import OrderedStrSet

logger = logging.getLogger(__name__)


class ReturnTypeConverter(
    ReturnTypeInnerList,
    ReturnTypeInnerTuple,
    ReturnTypeInnerDict,
    ReturnTypeConverterBase,
):
    REG_RETURN = re.compile(r'return ([^;]+);')

    def getStrReturnType(self) -> str:
        if (ret := self.getReturnType()) != Parameter.empty:
            return str(ret)
        return 'object'

    def getReturnType(self) -> RawRepr | type[Parameter.empty]:
        returnTypes = UnionArgument(self._genReturnType())
        ret = RawRepr(*returnTypes)
        # we must unpack `returnTypes` first,
        # so imports are generated by `UnionArgument`
        if ret != Parameter.empty:
            self.requiredImports.update(returnTypes.imports)
        return ret

    def _genReturnType(self) -> Iterable[RetType]:
        for match in self.REG_RETURN.finditer(self.functionBody):
            if self._isInsideLambda(match.start()):
                continue
            try:
                yield self.getExpressionType(match.group(1), match.end())
            except InvalidReturnType:
                continue

    LAMBDA_REG = re.compile(r'')

    def _isInsideLambda(self, pos: int) -> bool:
        """Check if position `pos` in `self.functionBody` is inside c++ lambda.

        This is a simplified grammar for c++ lambda using PEP 617 grammar specification.
        https://docs.python.org/3/reference/grammar.html#full-grammar-specification
        https://en.cppreference.com/w/cpp/language/lambda

        lambda:
            '[' captures ']'
            ('<' template-params '>')?
            (spec)?
            ('->' trailing-type)?
            '{' (`body`)? '}'
        """
        searchPos = pos
        while (br := self.functionBody.rfind('{', 0, searchPos)) != -1:
            searchPos = br

            if not self._isSameNumberOfChar('{', '}', br, pos, diff=1):
                continue

            searchSquareBr = br
            while (sq := self.functionBody.rfind('[', 0, searchSquareBr)) != -1:
                searchSquareBr = sq

                if self.functionBody.find(';', sq, br) != -1:
                    continue  # this is probably an expression

                if not self._isSameNumberOfChar('{', '}', sq, br):
                    continue
                if not self._isSameNumberOfChar('(', ')', sq, br):
                    continue
                if not self._isSameNumberOfChar('[', ']', sq, br):
                    continue

                # so we probably found a lambda `[` nad `{`, but is `pos` inside lambda?
                lambdaBody = findFunctionCall(self.functionBody, br)
                if br + len(lambdaBody) < pos:
                    continue

                logger.debug(
                    f"This is probably lambda expression "
                    f"(in `{self.functionName}` function)?\n"
                    f"{self.functionBody[sq:br + 1]}"
                )
                return True

        return False

    def _isSameNumberOfChar(
        self, charA: str, charB: str, start: int, end: int, diff: int = 0
    ) -> bool:
        openB = self.functionBody.count(charA, start, end)
        closeB = self.functionBody.count(charB, start, end)
        return openB == closeB + diff

    EXCEPTION_SET_STRING_REG = re.compile(r'PyErr_SetString\(([^;]+)\);')
    EXCEPTION_PY_REG = re.compile(r'throw\s+Py\s*::\s*(?P<exc>\w+)\((?P<args>[^;]*)\);')

    def getExceptionsFromCode(self):
        exceptions = OrderedStrSet()

        for exceptionMatch in self.EXCEPTION_PY_REG.finditer(self.functionBody):
            exceptionName = exceptionMatch.group('exc')
            if exceptionName == 'Exception' and (
                exceptionArgs := exceptionMatch.group('args')
            ):
                args = list(
                    generateExpressionUntilChar(
                        exceptionArgs, 0, ',', bracketL='(', bracketR=')'
                    )
                )
                if realExceptionName := args[0]:
                    exceptions.add(
                        exceptionContainer.getExceptionText(realExceptionName)
                    )
                    continue

            if validatePythonValue(exceptionName) is None:
                logger.error(f'Invalid exception value: {exceptionName}')
            else:
                exceptions.add(exceptionName)

        for exceptionMatch in self.EXCEPTION_SET_STRING_REG.finditer(self.functionBody):
            funArgs = list(genFuncArgs(exceptionMatch.group()))
            exceptions.add(exceptionContainer.getExceptionText(funArgs[0]))

        return exceptions
